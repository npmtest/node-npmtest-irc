{"/home/travis/build/npmtest/node-npmtest-irc/test.js":"/* istanbul instrument in package npmtest_irc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-irc/lib.npmtest_irc.js":"/* istanbul instrument in package npmtest_irc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_irc = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_irc = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-irc/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-irc && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_irc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_irc\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_irc.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_irc.rollup.js'] =\n            local.assetsDict['/assets.npmtest_irc.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_irc.__dirname +\n                    '/lib.npmtest_irc.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-irc/irc/lib/irc.js":"/*\n    irc.js - Node JS IRC client library\n\n    (C) Copyright Martyn Smith 2010\n\n    This library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this library.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nexports.Client = Client;\nvar net  = require('net');\nvar tls  = require('tls');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nvar colors = require('./colors');\nvar parseMessage = require('./parse_message');\nexports.colors = colors;\nvar CyclingPingTimer = require('./cycling_ping_timer.js');\n\nvar lineDelimiter = new RegExp('\\r\\n|\\r|\\n')\n\nfunction Client(server, nick, opt) {\n    var self = this;\n    self.opt = {\n        server: server,\n        nick: nick,\n        password: null,\n        userName: 'nodebot',\n        realName: 'nodeJS IRC client',\n        port: 6667,\n        localAddress: null,\n        debug: false,\n        showErrors: false,\n        autoRejoin: false,\n        autoConnect: true,\n        channels: [],\n        retryCount: null,\n        retryDelay: 2000,\n        secure: false,\n        selfSigned: false,\n        certExpired: false,\n        floodProtection: false,\n        floodProtectionDelay: 1000,\n        sasl: false,\n        stripColors: false,\n        channelPrefixes: '&#',\n        messageSplit: 512,\n        encoding: false,\n        webirc: {\n          pass: '',\n          ip: '',\n          host: ''\n        },\n        millisecondsOfSilenceBeforePingSent: 15 * 1000,\n        millisecondsBeforePingTimeout: 8 * 1000\n    };\n\n    // Features supported by the server\n    // (initial values are RFC 1459 defaults. Zeros signify\n    // no default or unlimited value)\n    self.supported = {\n        channel: {\n            idlength: [],\n            length: 200,\n            limit: [],\n            modes: { a: '', b: '', c: '', d: ''},\n            types: self.opt.channelPrefixes\n        },\n        kicklength: 0,\n        maxlist: [],\n        maxtargets: [],\n        modes: 3,\n        nicklength: 9,\n        topiclength: 0,\n        usermodes: ''\n    };\n\n    if (typeof arguments[2] == 'object') {\n        var keys = Object.keys(self.opt);\n        for (var i = 0; i < keys.length; i++) {\n            var k = keys[i];\n            if (arguments[2][k] !== undefined)\n                self.opt[k] = arguments[2][k];\n        }\n    }\n\n    if (self.opt.floodProtection) {\n        self.activateFloodProtection();\n    }\n\n    self.hostMask = '';\n\n    // TODO - fail if nick or server missing\n    // TODO - fail if username has a space in it\n    if (self.opt.autoConnect === true) {\n        self.connect();\n    }\n\n    self.addListener('raw', function(message) {\n        var channels = [],\n            channel,\n            nick,\n            from,\n            text,\n            to;\n\n        switch (message.command) {\n            case 'rpl_welcome':\n                // Set nick to whatever the server decided it really is\n                // (normally this is because you chose something too long and\n                // the server has shortened it\n                self.nick = message.args[0];\n                // Note our hostmask to use it in splitting long messages.\n                // We don't send our hostmask when issuing PRIVMSGs or NOTICEs,\n                // of course, but rather the servers on the other side will\n                // include it in messages and will truncate what we send if\n                // the string is too long. Therefore, we need to be considerate\n                // neighbors and truncate our messages accordingly.\n                var welcomeStringWords = message.args[1].split(/\\s+/);\n                self.hostMask = welcomeStringWords[welcomeStringWords.length - 1];\n                self._updateMaxLineLength();\n                self.emit('registered', message);\n                self.whois(self.nick, function(args) {\n                    self.nick = args.nick;\n                    self.hostMask = args.user + '@' + args.host;\n                    self._updateMaxLineLength();\n                });\n                break;\n            case 'rpl_myinfo':\n                self.supported.usermodes = message.args[3];\n                break;\n            case 'rpl_isupport':\n                message.args.forEach(function(arg) {\n                    var match;\n                    match = arg.match(/([A-Z]+)=(.*)/);\n                    if (match) {\n                        var param = match[1];\n                        var value = match[2];\n                        switch (param) {\n                            case 'CHANLIMIT':\n                                value.split(',').forEach(function(val) {\n                                    val = val.split(':');\n                                    self.supported.channel.limit[val[0]] = parseInt(val[1]);\n                                });\n                                break;\n                            case 'CHANMODES':\n                                value = value.split(',');\n                                var type = ['a', 'b', 'c', 'd'];\n                                for (var i = 0; i < type.length; i++) {\n                                    self.supported.channel.modes[type[i]] += value[i];\n                                }\n                                break;\n                            case 'CHANTYPES':\n                                self.supported.channel.types = value;\n                                break;\n                            case 'CHANNELLEN':\n                                self.supported.channel.length = parseInt(value);\n                                break;\n                            case 'IDCHAN':\n                                value.split(',').forEach(function(val) {\n                                    val = val.split(':');\n                                    self.supported.channel.idlength[val[0]] = val[1];\n                                });\n                                break;\n                            case 'KICKLEN':\n                                self.supported.kicklength = value;\n                                break;\n                            case 'MAXLIST':\n                                value.split(',').forEach(function(val) {\n                                    val = val.split(':');\n                                    self.supported.maxlist[val[0]] = parseInt(val[1]);\n                                });\n                                break;\n                            case 'NICKLEN':\n                                self.supported.nicklength = parseInt(value);\n                                break;\n                            case 'PREFIX':\n                                match = value.match(/\\((.*?)\\)(.*)/);\n                                if (match) {\n                                    match[1] = match[1].split('');\n                                    match[2] = match[2].split('');\n                                    while (match[1].length) {\n                                        self.modeForPrefix[match[2][0]] = match[1][0];\n                                        self.supported.channel.modes.b += match[1][0];\n                                        self.prefixForMode[match[1].shift()] = match[2].shift();\n                                    }\n                                }\n                                break;\n                            case 'STATUSMSG':\n                                break;\n                            case 'TARGMAX':\n                                value.split(',').forEach(function(val) {\n                                    val = val.split(':');\n                                    val[1] = (!val[1]) ? 0 : parseInt(val[1]);\n                                    self.supported.maxtargets[val[0]] = val[1];\n                                });\n                                break;\n                            case 'TOPICLEN':\n                                self.supported.topiclength = parseInt(value);\n                                break;\n                        }\n                    }\n                });\n                break;\n            case 'rpl_yourhost':\n            case 'rpl_created':\n            case 'rpl_luserclient':\n            case 'rpl_luserop':\n            case 'rpl_luserchannels':\n            case 'rpl_luserme':\n            case 'rpl_localusers':\n            case 'rpl_globalusers':\n            case 'rpl_statsconn':\n            case 'rpl_luserunknown':\n            case '396':\n            case '042':\n                // Random welcome crap, ignoring\n                break;\n            case 'err_nicknameinuse':\n                if (typeof (self.opt.nickMod) == 'undefined')\n                    self.opt.nickMod = 0;\n                self.opt.nickMod++;\n                self.send('NICK', self.opt.nick + self.opt.nickMod);\n                self.nick = self.opt.nick + self.opt.nickMod;\n                self._updateMaxLineLength();\n                break;\n            case 'PING':\n                self.send('PONG', message.args[0]);\n                self.emit('ping', message.args[0]);\n                break;\n            case 'PONG':\n                self.emit('pong', message.args[0]);\n                break;\n            case 'NOTICE':\n                from = message.nick;\n                to = message.args[0];\n                if (!to) {\n                    to = null;\n                }\n                text = message.args[1] || '';\n                if (text[0] === '\\u0001' && text.lastIndexOf('\\u0001') > 0) {\n                    self._handleCTCP(from, to, text, 'notice', message);\n                    break;\n                }\n                self.emit('notice', from, to, text, message);\n\n                if (self.opt.debug && to == self.nick)\n                    util.log('GOT NOTICE from ' + (from ? '\"' + from + '\"' : 'the server') + ': \"' + text + '\"');\n                break;\n            case 'MODE':\n                if (self.opt.debug)\n                    util.log('MODE: ' + message.args[0] + ' sets mode: ' + message.args[1]);\n\n                channel = self.chanData(message.args[0]);\n                if (!channel) break;\n                var modeList = message.args[1].split('');\n                var adding = true;\n                var modeArgs = message.args.slice(2);\n                modeList.forEach(function(mode) {\n                    if (mode == '+') {\n                        adding = true;\n                        return;\n                    }\n                    if (mode == '-') {\n                        adding = false;\n                        return;\n                    }\n\n                    var eventName = (adding ? '+' : '-') + 'mode';\n                    var supported = self.supported.channel.modes;\n                    var modeArg;\n                    var chanModes = function(mode, param) {\n                        var arr = param && Array.isArray(param);\n                        if (adding) {\n                            if (channel.mode.indexOf(mode) == -1) {\n                                channel.mode += mode;\n                            }\n                            if (param === undefined) {\n                                channel.modeParams[mode] = [];\n                            } else if (arr) {\n                                channel.modeParams[mode] = channel.modeParams[mode] ?\n                                    channel.modeParams[mode].concat(param) : param;\n                            } else {\n                                channel.modeParams[mode] = [param];\n                            }\n                        } else {\n                            if (arr) {\n                                channel.modeParams[mode] = channel.modeParams[mode]\n                                    .filter(function(v) { return v !== param[0]; });\n                            }\n                            if (!arr || channel.modeParams[mode].length === 0) {\n                                channel.mode = channel.mode.replace(mode, '');\n                                delete channel.modeParams[mode];\n                            }\n                        }\n                    };\n                    if (mode in self.prefixForMode) {\n                        modeArg = modeArgs.shift();\n                        if (channel.users.hasOwnProperty(modeArg)) {\n                            if (adding) {\n                                if (channel.users[modeArg].indexOf(self.prefixForMode[mode]) === -1)\n                                    channel.users[modeArg] += self.prefixForMode[mode];\n                            } else channel.users[modeArg] = channel.users[modeArg].replace(self.prefixForMode[mode], '');\n                        }\n                        self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);\n                    } else if (supported.a.indexOf(mode) !== -1) {\n                        modeArg = modeArgs.shift();\n                        chanModes(mode, [modeArg]);\n                        self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);\n                    } else if (supported.b.indexOf(mode) !== -1) {\n                        modeArg = modeArgs.shift();\n                        chanModes(mode, modeArg);\n                        self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);\n                    } else if (supported.c.indexOf(mode) !== -1) {\n                        if (adding) modeArg = modeArgs.shift();\n                        else modeArg = undefined;\n                        chanModes(mode, modeArg);\n                        self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);\n                    } else if (supported.d.indexOf(mode) !== -1) {\n                        chanModes(mode);\n                        self.emit(eventName, message.args[0], message.nick, mode, undefined, message);\n                    }\n                });\n                break;\n            case 'NICK':\n                if (message.nick == self.nick) {\n                    // the user just changed their own nick\n                    self.nick = message.args[0];\n                    self._updateMaxLineLength();\n                }\n\n                if (self.opt.debug)\n                    util.log('NICK: ' + message.nick + ' changes nick to ' + message.args[0]);\n\n                channels = [];\n\n                // TODO better way of finding what channels a user is in?\n                Object.keys(self.chans).forEach(function(channame) {\n                    var channel = self.chans[channame];\n                    channel.users[message.args[0]] = channel.users[message.nick];\n                    delete channel.users[message.nick];\n                    channels.push(channame);\n                });\n\n                // old nick, new nick, channels\n                self.emit('nick', message.nick, message.args[0], channels, message);\n                break;\n            case 'rpl_motdstart':\n                self.motd = message.args[1] + '\\n';\n                break;\n            case 'rpl_motd':\n                self.motd += message.args[1] + '\\n';\n                break;\n            case 'rpl_endofmotd':\n            case 'err_nomotd':\n                self.motd += message.args[1] + '\\n';\n                self.emit('motd', self.motd);\n                break;\n            case 'rpl_namreply':\n                channel = self.chanData(message.args[2]);\n                var users = message.args[3].trim().split(/ +/);\n                if (channel) {\n                    users.forEach(function(user) {\n                        var match = user.match(/^(.)(.*)$/);\n                        if (match) {\n                            if (match[1] in self.modeForPrefix) {\n                                channel.users[match[2]] = match[1];\n                            }\n                            else {\n                                channel.users[match[1] + match[2]] = '';\n                            }\n                        }\n                    });\n                }\n                break;\n            case 'rpl_endofnames':\n                channel = self.chanData(message.args[1]);\n                if (channel) {\n                    self.emit('names', message.args[1], channel.users);\n                    self.emit('names' + message.args[1], channel.users);\n                    self.send('MODE', message.args[1]);\n                }\n                break;\n            case 'rpl_topic':\n                channel = self.chanData(message.args[1]);\n                if (channel) {\n                    channel.topic = message.args[2];\n                }\n                break;\n            case 'rpl_away':\n                self._addWhoisData(message.args[1], 'away', message.args[2], true);\n                break;\n            case 'rpl_whoisuser':\n                self._addWhoisData(message.args[1], 'user', message.args[2]);\n                self._addWhoisData(message.args[1], 'host', message.args[3]);\n                self._addWhoisData(message.args[1], 'realname', message.args[5]);\n                break;\n            case 'rpl_whoisidle':\n                self._addWhoisData(message.args[1], 'idle', message.args[2]);\n                break;\n            case 'rpl_whoischannels':\n               // TODO - clean this up?\n                self._addWhoisData(message.args[1], 'channels', message.args[2].trim().split(/\\s+/));\n                break;\n            case 'rpl_whoisserver':\n                self._addWhoisData(message.args[1], 'server', message.args[2]);\n                self._addWhoisData(message.args[1], 'serverinfo', message.args[3]);\n                break;\n            case 'rpl_whoisoperator':\n                self._addWhoisData(message.args[1], 'operator', message.args[2]);\n                break;\n            case '330': // rpl_whoisaccount?\n                self._addWhoisData(message.args[1], 'account', message.args[2]);\n                self._addWhoisData(message.args[1], 'accountinfo', message.args[3]);\n                break;\n            case 'rpl_endofwhois':\n                self.emit('whois', self._clearWhoisData(message.args[1]));\n                break;\n            case 'rpl_whoreply':\n                self._addWhoisData(message.args[5], 'user', message.args[2]);\n                self._addWhoisData(message.args[5], 'host', message.args[3]);\n                self._addWhoisData(message.args[5], 'server', message.args[4]);\n                self._addWhoisData(message.args[5], 'realname', /[0-9]+\\s*(.+)/g.exec(message.args[7])[1]);\n                // emit right away because rpl_endofwho doesn't contain nick\n                self.emit('whois', self._clearWhoisData(message.args[5]));\n                break;\n            case 'rpl_liststart':\n                self.channellist = [];\n                self.emit('channellist_start');\n                break;\n            case 'rpl_list':\n                channel = {\n                    name: message.args[1],\n                    users: message.args[2],\n                    topic: message.args[3]\n                };\n                self.emit('channellist_item', channel);\n                self.channellist.push(channel);\n                break;\n            case 'rpl_listend':\n                self.emit('channellist', self.channellist);\n                break;\n            case 'rpl_topicwhotime':\n                channel = self.chanData(message.args[1]);\n                if (channel) {\n                    channel.topicBy = message.args[2];\n                    // channel, topic, nick\n                    self.emit('topic', message.args[1], channel.topic, channel.topicBy, message);\n                }\n                break;\n            case 'TOPIC':\n                // channel, topic, nick\n                self.emit('topic', message.args[0], message.args[1], message.nick, message);\n\n                channel = self.chanData(message.args[0]);\n                if (channel) {\n                    channel.topic = message.args[1];\n                    channel.topicBy = message.nick;\n                }\n                break;\n            case 'rpl_channelmodeis':\n                channel = self.chanData(message.args[1]);\n                if (channel) {\n                    channel.mode = message.args[2];\n                }\n                break;\n            case 'rpl_creationtime':\n                channel = self.chanData(message.args[1]);\n                if (channel) {\n                    channel.created = message.args[2];\n                }\n                break;\n            case 'JOIN':\n                // channel, who\n                if (self.nick == message.nick) {\n                    self.chanData(message.args[0], true);\n                }\n                else {\n                    channel = self.chanData(message.args[0]);\n                    if (channel && channel.users) {\n                        channel.users[message.nick] = '';\n                    }\n                }\n                self.emit('join', message.args[0], message.nick, message);\n                self.emit('join' + message.args[0], message.nick, message);\n                if (message.args[0] != message.args[0].toLowerCase()) {\n                    self.emit('join' + message.args[0].toLowerCase(), message.nick, message);\n                }\n                break;\n            case 'PART':\n                // channel, who, reason\n                self.emit('part', message.args[0], message.nick, message.args[1], message);\n                self.emit('part' + message.args[0], message.nick, message.args[1], message);\n                if (message.args[0] != message.args[0].toLowerCase()) {\n                    self.emit('part' + message.args[0].toLowerCase(), message.nick, message.args[1], message);\n                }\n                if (self.nick == message.nick) {\n                    channel = self.chanData(message.args[0]);\n                    delete self.chans[channel.key];\n                }\n                else {\n                    channel = self.chanData(message.args[0]);\n                    if (channel && channel.users) {\n                        delete channel.users[message.nick];\n                    }\n                }\n                break;\n            case 'KICK':\n                // channel, who, by, reason\n                self.emit('kick', message.args[0], message.args[1], message.nick, message.args[2], message);\n                self.emit('kick' + message.args[0], message.args[1], message.nick, message.args[2], message);\n                if (message.args[0] != message.args[0].toLowerCase()) {\n                    self.emit('kick' + message.args[0].toLowerCase(),\n                              message.args[1], message.nick, message.args[2], message);\n                }\n\n                if (self.nick == message.args[1]) {\n                    channel = self.chanData(message.args[0]);\n                    delete self.chans[channel.key];\n                }\n                else {\n                    channel = self.chanData(message.args[0]);\n                    if (channel && channel.users) {\n                        delete channel.users[message.args[1]];\n                    }\n                }\n                break;\n            case 'KILL':\n                nick = message.args[0];\n                channels = [];\n                Object.keys(self.chans).forEach(function(channame) {\n                    var channel = self.chans[channame];\n                    channels.push(channame);\n                    delete channel.users[nick];\n                });\n                self.emit('kill', nick, message.args[1], channels, message);\n                break;\n            case 'PRIVMSG':\n                from = message.nick;\n                to = message.args[0];\n                text = message.args[1] || '';\n                if (text[0] === '\\u0001' && text.lastIndexOf('\\u0001') > 0) {\n                    self._handleCTCP(from, to, text, 'privmsg', message);\n                    break;\n                }\n                self.emit('message', from, to, text, message);\n                if (self.supported.channel.types.indexOf(to.charAt(0)) !== -1) {\n                    self.emit('message#', from, to, text, message);\n                    self.emit('message' + to, from, text, message);\n                    if (to != to.toLowerCase()) {\n                        self.emit('message' + to.toLowerCase(), from, text, message);\n                    }\n                }\n                if (to.toUpperCase() === self.nick.toUpperCase()) self.emit('pm', from, text, message);\n\n                if (self.opt.debug && to == self.nick)\n                    util.log('GOT MESSAGE from ' + from + ': ' + text);\n                break;\n            case 'INVITE':\n                from = message.nick;\n                to = message.args[0];\n                channel = message.args[1];\n                self.emit('invite', channel, from, message);\n                break;\n            case 'QUIT':\n                if (self.opt.debug)\n                    util.log('QUIT: ' + message.prefix + ' ' + message.args.join(' '));\n                if (self.nick == message.nick) {\n                    // TODO handle?\n                    break;\n                }\n                // handle other people quitting\n\n                channels = [];\n\n                // TODO better way of finding what channels a user is in?\n                Object.keys(self.chans).forEach(function(channame) {\n                    var channel = self.chans[channame];\n                    delete channel.users[message.nick];\n                    channels.push(channame);\n                });\n\n                // who, reason, channels\n                self.emit('quit', message.nick, message.args[0], channels, message);\n                break;\n\n            // for sasl\n            case 'CAP':\n                if (message.args[0] === '*' &&\n                     message.args[1] === 'ACK' &&\n                     message.args[2] === 'sasl ') // there's a space after sasl\n                    self.send('AUTHENTICATE', 'PLAIN');\n                break;\n            case 'AUTHENTICATE':\n                if (message.args[0] === '+') self.send('AUTHENTICATE',\n                    new Buffer(\n                        self.opt.nick + '\\0' +\n                        self.opt.userName + '\\0' +\n                        self.opt.password\n                    ).toString('base64'));\n                break;\n            case '903':\n                self.send('CAP', 'END');\n                break;\n\n            case 'err_umodeunknownflag':\n                if (self.opt.showErrors)\n                    util.log('\\u001b[01;31mERROR: ' + util.inspect(message) + '\\u001b[0m');\n                break;\n\n            case 'err_erroneusnickname':\n                if (self.opt.showErrors)\n                    util.log('\\u001b[01;31mERROR: ' + util.inspect(message) + '\\u001b[0m');\n                self.emit('error', message);\n                break;\n\n            // Commands relating to OPER\n            case 'err_nooperhost':\n                if (self.opt.showErrors) {\n                    self.emit('error', message);\n                    if (self.opt.showErrors)\n                        util.log('\\u001b[01;31mERROR: ' + util.inspect(message) + '\\u001b[0m');\n                }\n                break;\n\n            case 'rpl_youreoper':\n                self.emit('opered');\n                break;\n\n            default:\n                if (message.commandType == 'error') {\n                    self.emit('error', message);\n                    if (self.opt.showErrors)\n                        util.log('\\u001b[01;31mERROR: ' + util.inspect(message) + '\\u001b[0m');\n                }\n                else {\n                    if (self.opt.debug)\n                        util.log('\\u001b[01;31mUnhandled message: ' + util.inspect(message) + '\\u001b[0m');\n                    break;\n                }\n        }\n    });\n\n    self.addListener('kick', function(channel, who, by, reason) {\n        if (self.opt.autoRejoin)\n            self.send.apply(self, ['JOIN'].concat(channel.split(' ')));\n    });\n    self.addListener('motd', function(motd) {\n        self.opt.channels.forEach(function(channel) {\n            self.send.apply(self, ['JOIN'].concat(channel.split(' ')));\n        });\n    });\n\n    EventEmitter.call(this);\n}\nutil.inherits(Client, EventEmitter);\n\nClient.prototype.conn = null;\nClient.prototype.prefixForMode = {};\nClient.prototype.modeForPrefix = {};\nClient.prototype.chans = {};\nClient.prototype._whoisData = {};\n\nClient.prototype.connectionTimedOut = function(conn) {\n    var self = this;\n    if (conn !== self.conn) {\n        // Only care about a timeout event if it came from the connection\n        // that is most current.\n        return;\n    }\n    self.end();\n};\n\n(function() {\n    var pingCounter = 1;\n    Client.prototype.connectionWantsPing = function(conn) {\n        var self = this;\n        if (conn !== self.conn) {\n            // Only care about a wantPing event if it came from the connection\n            // that is most current.\n            return;\n        }\n        self.send('PING', (pingCounter++).toString());\n    };\n}());\n\nClient.prototype.chanData = function(name, create) {\n    var key = name.toLowerCase();\n    if (create) {\n        this.chans[key] = this.chans[key] || {\n            key: key,\n            serverName: name,\n            users: {},\n            modeParams: {},\n            mode: ''\n        };\n    }\n\n    return this.chans[key];\n};\n\nClient.prototype._connectionHandler = function() {\n    if (this.opt.webirc.ip && this.opt.webirc.pass && this.opt.webirc.host) {\n        this.send('WEBIRC', this.opt.webirc.pass, this.opt.userName, this.opt.webirc.host, this.opt.webirc.ip);\n    }\n    if (this.opt.sasl) {\n        // see http://ircv3.atheme.org/extensions/sasl-3.1\n        this.send('CAP REQ', 'sasl');\n    } else if (this.opt.password) {\n        this.send('PASS', this.opt.password);\n    }\n    if (this.opt.debug)\n        util.log('Sending irc NICK/USER');\n    this.send('NICK', this.opt.nick);\n    this.nick = this.opt.nick;\n    this._updateMaxLineLength();\n    this.send('USER', this.opt.userName, 8, '*', this.opt.realName);\n\n    this.conn.cyclingPingTimer.start();\n\n    this.emit('connect');\n};\n\nClient.prototype.connect = function(retryCount, callback) {\n    if (typeof (retryCount) === 'function') {\n        callback = retryCount;\n        retryCount = undefined;\n    }\n    retryCount = retryCount || 0;\n    if (typeof (callback) === 'function') {\n        this.once('registered', callback);\n    }\n    var self = this;\n    self.chans = {};\n\n    // socket opts\n    var connectionOpts = {\n        host: self.opt.server,\n        port: self.opt.port\n    };\n\n    // local address to bind to\n    if (self.opt.localAddress)\n        connectionOpts.localAddress = self.opt.localAddress;\n\n    // try to connect to the server\n    if (self.opt.secure) {\n        connectionOpts.rejectUnauthorized = !self.opt.selfSigned;\n\n        if (typeof self.opt.secure == 'object') {\n            // copy \"secure\" opts to options passed to connect()\n            for (var f in self.opt.secure) {\n                connectionOpts[f] = self.opt.secure[f];\n            }\n        }\n\n        self.conn = tls.connect(connectionOpts, function() {\n            // callback called only after successful socket connection\n            self.conn.connected = true;\n            if (self.conn.authorized ||\n                (self.opt.selfSigned &&\n                    (self.conn.authorizationError   === 'DEPTH_ZERO_SELF_SIGNED_CERT' ||\n                     self.conn.authorizationError === 'UNABLE_TO_VERIFY_LEAF_SIGNATURE' ||\n                     self.conn.authorizationError === 'SELF_SIGNED_CERT_IN_CHAIN')) ||\n                (self.opt.certExpired &&\n                 self.conn.authorizationError === 'CERT_HAS_EXPIRED')) {\n                // authorization successful\n\n                if (!self.opt.encoding) {\n                    self.conn.setEncoding('utf-8');\n                }\n\n                if (self.opt.certExpired &&\n                    self.conn.authorizationError === 'CERT_HAS_EXPIRED') {\n                    util.log('Connecting to server with expired certificate');\n                }\n\n                self._connectionHandler();\n            } else {\n                // authorization failed\n                util.log(self.conn.authorizationError);\n            }\n        });\n    } else {\n        self.conn = net.createConnection(connectionOpts, self._connectionHandler.bind(self));\n    }\n    self.conn.requestedDisconnect = false;\n    self.conn.setTimeout(0);\n\n    // Each connection gets its own CyclingPingTimer. The connection forwards the timer's 'timeout' and 'wantPing' events\n    // to the client object via calling the connectionTimedOut() and connectionWantsPing() functions.\n    //\n    // Since the client's \"current connection\" value changes over time because of retry functionality,\n    // the client should ignore timeout/wantPing events that come from old connections.\n    self.conn.cyclingPingTimer = new CyclingPingTimer(self);\n    (function(conn) {\n        conn.cyclingPingTimer.on('pingTimeout', function() {\n            self.connectionTimedOut(conn);\n        });\n        conn.cyclingPingTimer.on('wantPing', function() {\n            self.connectionWantsPing(conn);\n        });\n    }(self.conn));\n\n    if (!self.opt.encoding) {\n        self.conn.setEncoding('utf8');\n    }\n\n    var buffer = new Buffer('');\n\n    function handleData(chunk) {\n        self.conn.cyclingPingTimer.notifyOfActivity();\n\n        if (typeof (chunk) === 'string') {\n            buffer += chunk;\n        } else {\n            buffer = Buffer.concat([buffer, chunk]);\n        }\n\n        var lines = self.convertEncoding(buffer).toString().split(lineDelimiter);\n\n        if (lines.pop()) {\n            // if buffer is not ended with \\r\\n, there's more chunks.\n            return;\n        } else {\n            // else, initialize the buffer.\n            buffer = new Buffer('');\n        }\n\n        lines.forEach(function iterator(line) {\n            if (line.length) {\n                var message = parseMessage(line, self.opt.stripColors);\n\n                try {\n                    self.emit('raw', message);\n                } catch (err) {\n                    if (!self.conn.requestedDisconnect) {\n                        throw err;\n                    }\n                }\n            }\n        });\n    }\n\n    self.conn.addListener('data', handleData);\n    self.conn.addListener('end', function() {\n        if (self.opt.debug)\n            util.log('Connection got \"end\" event');\n    });\n    self.conn.addListener('close', function() {\n        if (self.opt.debug)\n            util.log('Connection got \"close\" event');\n\n        if (self.conn && self.conn.requestedDisconnect)\n            return;\n        if (self.opt.debug)\n            util.log('Disconnected: reconnecting');\n        if (self.opt.retryCount !== null && retryCount >= self.opt.retryCount) {\n            if (self.opt.debug) {\n                util.log('Maximum retry count (' + self.opt.retryCount + ') reached. Aborting');\n            }\n            self.emit('abort', self.opt.retryCount);\n            return;\n        }\n\n        if (self.opt.debug) {\n            util.log('Waiting ' + self.opt.retryDelay + 'ms before retrying');\n        }\n        setTimeout(function() {\n            self.connect(retryCount + 1);\n        }, self.opt.retryDelay);\n    });\n    self.conn.addListener('error', function(exception) {\n        self.emit('netError', exception);\n        if (self.opt.debug) {\n            util.log('Network error: ' + exception);\n        }\n    });\n};\n\nClient.prototype.end = function() {\n    if (this.conn) {\n        this.conn.cyclingPingTimer.stop();\n        this.conn.destroy();\n    }\n    this.conn = null;\n};\n\nClient.prototype.disconnect = function(message, callback) {\n    if (typeof (message) === 'function') {\n        callback = message;\n        message = undefined;\n    }\n    message = message || 'node-irc says goodbye';\n    var self = this;\n    if (self.conn.readyState == 'open') {\n        var sendFunction;\n        if (self.opt.floodProtection) {\n            sendFunction = self._sendImmediate;\n            self._clearCmdQueue();\n        } else {\n            sendFunction = self.send;\n        }\n        sendFunction.call(self, 'QUIT', message);\n    }\n    self.conn.requestedDisconnect = true;\n    if (typeof (callback) === 'function') {\n        self.conn.once('end', callback);\n    }\n    self.conn.end();\n};\n\nClient.prototype.send = function(command) {\n    var args = Array.prototype.slice.call(arguments);\n\n    // Note that the command arg is included in the args array as the first element\n\n    if (args[args.length - 1].match(/\\s/) || args[args.length - 1].match(/^:/) || args[args.length - 1] === '') {\n        args[args.length - 1] = ':' + args[args.length - 1];\n    }\n\n    if (this.opt.debug)\n        util.log('SEND: ' + args.join(' '));\n\n    if (!this.conn.requestedDisconnect) {\n        this.conn.write(args.join(' ') + '\\r\\n');\n    }\n};\n\nClient.prototype.activateFloodProtection = function(interval) {\n\n    var cmdQueue = [],\n        safeInterval = interval || this.opt.floodProtectionDelay,\n        self = this,\n        origSend = this.send,\n        dequeue;\n\n    // Wrapper for the original function. Just put everything to on central\n    // queue.\n    this.send = function() {\n        cmdQueue.push(arguments);\n    };\n\n    this._sendImmediate = function() {\n        origSend.apply(self, arguments);\n    };\n\n    this._clearCmdQueue = function() {\n        cmdQueue = [];\n    };\n\n    dequeue = function() {\n        var args = cmdQueue.shift();\n        if (args) {\n            origSend.apply(self, args);\n        }\n    };\n\n    // Slowly unpack the queue without flooding.\n    setInterval(dequeue, safeInterval);\n    dequeue();\n};\n\nClient.prototype.join = function(channel, callback) {\n    var channelName =  channel.split(' ')[0];\n    this.once('join' + channelName, function() {\n        // if join is successful, add this channel to opts.channels\n        // so that it will be re-joined upon reconnect (as channels\n        // specified in options are)\n        if (this.opt.channels.indexOf(channel) == -1) {\n            this.opt.channels.push(channel);\n        }\n\n        if (typeof (callback) == 'function') {\n            return callback.apply(this, arguments);\n        }\n    });\n    this.send.apply(this, ['JOIN'].concat(channel.split(' ')));\n};\n\nClient.prototype.part = function(channel, message, callback) {\n    if (typeof (message) === 'function') {\n        callback = message;\n        message = undefined;\n    }\n    if (typeof (callback) == 'function') {\n        this.once('part' + channel, callback);\n    }\n\n    // remove this channel from this.opt.channels so we won't rejoin\n    // upon reconnect\n    if (this.opt.channels.indexOf(channel) != -1) {\n        this.opt.channels.splice(this.opt.channels.indexOf(channel), 1);\n    }\n\n    if (message) {\n        this.send('PART', channel, message);\n    } else {\n        this.send('PART', channel);\n    }\n};\n\nClient.prototype.action = function(channel, text) {\n    var self = this;\n    if (typeof text !== 'undefined') {\n        text.toString().split(/\\r?\\n/).filter(function(line) {\n            return line.length > 0;\n        }).forEach(function(line) {\n            self.say(channel, '\\u0001ACTION ' + line + '\\u0001');\n        });\n    }\n};\n\nClient.prototype._splitLongLines = function(words, maxLength, destination) {\n    maxLength = maxLength || 450; // If maxLength hasn't been initialized yet, prefer an arbitrarily low line length over crashing.\n    if (words.length == 0) {\n        return destination;\n    }\n    if (words.length <= maxLength) {\n        destination.push(words);\n        return destination;\n    }\n    var c = words[maxLength];\n    var cutPos;\n    var wsLength = 1;\n    if (c.match(/\\s/)) {\n        cutPos = maxLength;\n    } else {\n        var offset = 1;\n        while ((maxLength - offset) > 0) {\n            var c = words[maxLength - offset];\n            if (c.match(/\\s/)) {\n                cutPos = maxLength - offset;\n                break;\n            }\n            offset++;\n        }\n        if (maxLength - offset <= 0) {\n            cutPos = maxLength;\n            wsLength = 0;\n        }\n    }\n    var part = words.substring(0, cutPos);\n    destination.push(part);\n    return this._splitLongLines(words.substring(cutPos + wsLength, words.length), maxLength, destination);\n};\n\nClient.prototype.say = function(target, text) {\n    this._speak('PRIVMSG', target, text);\n};\n\nClient.prototype.notice = function(target, text) {\n    this._speak('NOTICE', target, text);\n};\n\nClient.prototype._speak = function(kind, target, text) {\n    var self = this;\n    var maxLength = Math.min(this.maxLineLength - target.length, this.opt.messageSplit);\n    if (typeof text !== 'undefined') {\n        text.toString().split(/\\r?\\n/).filter(function(line) {\n            return line.length > 0;\n        }).forEach(function(line) {\n            var linesToSend = self._splitLongLines(line, maxLength, []);\n            linesToSend.forEach(function(toSend) {\n                self.send(kind, target, toSend);\n                if (kind == 'PRIVMSG') {\n                    self.emit('selfMessage', target, toSend);\n                }\n            });\n        });\n    }\n};\n\nClient.prototype.whois = function(nick, callback) {\n    if (typeof callback === 'function') {\n        var callbackWrapper = function(info) {\n            if (info.nick.toLowerCase() == nick.toLowerCase()) {\n                this.removeListener('whois', callbackWrapper);\n                return callback.apply(this, arguments);\n            }\n        };\n        this.addListener('whois', callbackWrapper);\n    }\n    this.send('WHOIS', nick);\n};\n\nClient.prototype.list = function() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('LIST');\n    this.send.apply(this, args);\n};\n\nClient.prototype._addWhoisData = function(nick, key, value, onlyIfExists) {\n    if (onlyIfExists && !this._whoisData[nick]) return;\n    this._whoisData[nick] = this._whoisData[nick] || {nick: nick};\n    this._whoisData[nick][key] = value;\n};\n\nClient.prototype._clearWhoisData = function(nick) {\n    // Ensure that at least the nick exists before trying to return\n    this._addWhoisData(nick, 'nick', nick);\n    var data = this._whoisData[nick];\n    delete this._whoisData[nick];\n    return data;\n};\n\nClient.prototype._handleCTCP = function(from, to, text, type, message) {\n    text = text.slice(1);\n    text = text.slice(0, text.indexOf('\\u0001'));\n    var parts = text.split(' ');\n    this.emit('ctcp', from, to, text, type, message);\n    this.emit('ctcp-' + type, from, to, text, message);\n    if (type === 'privmsg' && text === 'VERSION')\n        this.emit('ctcp-version', from, to, message);\n    if (parts[0] === 'ACTION' && parts.length > 1)\n        this.emit('action', from, to, parts.slice(1).join(' '), message);\n    if (parts[0] === 'PING' && type === 'privmsg' && parts.length > 1)\n        this.ctcp(from, 'notice', text);\n};\n\nClient.prototype.ctcp = function(to, type, text) {\n    return this[type === 'privmsg' ? 'say' : 'notice'](to, '\\u0001' + text + '\\u0001');\n};\n\nClient.prototype.convertEncoding = function(str) {\n    var self = this, out = str;\n\n    if (self.opt.encoding) {\n        try {\n            var charsetDetector = require('node-icu-charset-detector');\n            var Iconv = require('iconv').Iconv;\n            var charset = charsetDetector.detectCharset(str);\n            var converter = new Iconv(charset.toString(), self.opt.encoding);\n\n            out = converter.convert(str);\n        } catch (err) {\n            if (self.opt.debug) {\n                util.log('\\u001b[01;31mERROR: ' + err + '\\u001b[0m');\n                util.inspect({ str: str, charset: charset });\n            }\n        }\n    }\n\n    return out;\n};\n// blatantly stolen from irssi's splitlong.pl. Thanks, Bjoern Krombholz!\nClient.prototype._updateMaxLineLength = function() {\n    // 497 = 510 - (\":\" + \"!\" + \" PRIVMSG \" + \" :\").length;\n    // target is determined in _speak() and subtracted there\n    this.maxLineLength = 497 - this.nick.length - this.hostMask.length;\n};\n","/home/travis/build/npmtest/node-npmtest-irc/irc/lib/colors.js":"var codes = {\n    white: '\\u000300',\n    black: '\\u000301',\n    dark_blue: '\\u000302',\n    dark_green: '\\u000303',\n    light_red: '\\u000304',\n    dark_red: '\\u000305',\n    magenta: '\\u000306',\n    orange: '\\u000307',\n    yellow: '\\u000308',\n    light_green: '\\u000309',\n    cyan: '\\u000310',\n    light_cyan: '\\u000311',\n    light_blue: '\\u000312',\n    light_magenta: '\\u000313',\n    gray: '\\u000314',\n    light_gray: '\\u000315',\n\n    bold: '\\u0002',\n    underline: '\\u001f',\n\n    reset: '\\u000f'\n};\nexports.codes = codes;\n\nfunction wrap(color, text, resetColor) {\n    if (codes[color]) {\n        text = codes[color] + text;\n        text += (codes[resetColor]) ? codes[resetColor] : codes.reset;\n    }\n    return text;\n}\nexports.wrap = wrap;\n","/home/travis/build/npmtest/node-npmtest-irc/irc/lib/parse_message.js":"var ircColors = require('irc-colors');\nvar replyFor = require('./codes');\n\n/**\n * parseMessage(line, stripColors)\n *\n * takes a raw \"line\" from the IRC server and turns it into an object with\n * useful keys\n * @param {String} line Raw message from IRC server.\n * @param {Boolean} stripColors If true, strip IRC colors.\n * @return {Object} A parsed message object.\n */\nmodule.exports = function parseMessage(line, stripColors) {\n    var message = {};\n    var match;\n\n    if (stripColors) {\n        line = ircColors.stripColorsAndStyle(line);\n    }\n\n    // Parse prefix\n    match = line.match(/^:([^ ]+) +/);\n    if (match) {\n        message.prefix = match[1];\n        line = line.replace(/^:[^ ]+ +/, '');\n        match = message.prefix.match(/^([_a-zA-Z0-9\\~\\[\\]\\\\`^{}|-]*)(!([^@]+)@(.*))?$/);\n        if (match) {\n            message.nick = match[1];\n            message.user = match[3];\n            message.host = match[4];\n        }\n        else {\n            message.server = message.prefix;\n        }\n    }\n\n    // Parse command\n    match = line.match(/^([^ ]+) */);\n    message.command = match[1];\n    message.rawCommand = match[1];\n    message.commandType = 'normal';\n    line = line.replace(/^[^ ]+ +/, '');\n\n    if (replyFor[message.rawCommand]) {\n        message.command     = replyFor[message.rawCommand].name;\n        message.commandType = replyFor[message.rawCommand].type;\n    }\n\n    message.args = [];\n    var middle, trailing;\n\n    // Parse parameters\n    if (line.search(/^:|\\s+:/) != -1) {\n        match = line.match(/(.*?)(?:^:|\\s+:)(.*)/);\n        middle = match[1].trimRight();\n        trailing = match[2];\n    }\n    else {\n        middle = line;\n    }\n\n    if (middle.length)\n        message.args = middle.split(/ +/);\n\n    if (typeof (trailing) != 'undefined' && trailing.length)\n        message.args.push(trailing);\n\n    return message;\n}\n","/home/travis/build/npmtest/node-npmtest-irc/irc/lib/codes.js":"module.exports = {\n   '001': {\n      name: 'rpl_welcome',\n      type: 'reply'\n   },\n   '002': {\n      name: 'rpl_yourhost',\n      type: 'reply'\n   },\n   '003': {\n      name: 'rpl_created',\n      type: 'reply'\n   },\n   '004': {\n      name: 'rpl_myinfo',\n      type: 'reply'\n   },\n   '005': {\n      name: 'rpl_isupport',\n      type: 'reply'\n   },\n   200: {\n      name: 'rpl_tracelink',\n      type: 'reply'\n   },\n   201: {\n      name: 'rpl_traceconnecting',\n      type: 'reply'\n   },\n   202: {\n      name: 'rpl_tracehandshake',\n      type: 'reply'\n   },\n   203: {\n      name: 'rpl_traceunknown',\n      type: 'reply'\n   },\n   204: {\n      name: 'rpl_traceoperator',\n      type: 'reply'\n   },\n   205: {\n      name: 'rpl_traceuser',\n      type: 'reply'\n   },\n   206: {\n      name: 'rpl_traceserver',\n      type: 'reply'\n   },\n   208: {\n      name: 'rpl_tracenewtype',\n      type: 'reply'\n   },\n   211: {\n      name: 'rpl_statslinkinfo',\n      type: 'reply'\n   },\n   212: {\n      name: 'rpl_statscommands',\n      type: 'reply'\n   },\n   213: {\n      name: 'rpl_statscline',\n      type: 'reply'\n   },\n   214: {\n      name: 'rpl_statsnline',\n      type: 'reply'\n   },\n   215: {\n      name: 'rpl_statsiline',\n      type: 'reply'\n   },\n   216: {\n      name: 'rpl_statskline',\n      type: 'reply'\n   },\n   218: {\n      name: 'rpl_statsyline',\n      type: 'reply'\n   },\n   219: {\n      name: 'rpl_endofstats',\n      type: 'reply'\n   },\n   221: {\n      name: 'rpl_umodeis',\n      type: 'reply'\n   },\n   241: {\n      name: 'rpl_statslline',\n      type: 'reply'\n   },\n   242: {\n      name: 'rpl_statsuptime',\n      type: 'reply'\n   },\n   243: {\n      name: 'rpl_statsoline',\n      type: 'reply'\n   },\n   244: {\n      name: 'rpl_statshline',\n      type: 'reply'\n   },\n   250: {\n      name: 'rpl_statsconn',\n      type: 'reply'\n   },\n   251: {\n      name: 'rpl_luserclient',\n      type: 'reply'\n   },\n   252: {\n      name: 'rpl_luserop',\n      type: 'reply'\n   },\n   253: {\n      name: 'rpl_luserunknown',\n      type: 'reply'\n   },\n   254: {\n      name: 'rpl_luserchannels',\n      type: 'reply'\n   },\n   255: {\n      name: 'rpl_luserme',\n      type: 'reply'\n   },\n   256: {\n      name: 'rpl_adminme',\n      type: 'reply'\n   },\n   257: {\n      name: 'rpl_adminloc1',\n      type: 'reply'\n   },\n   258: {\n      name: 'rpl_adminloc2',\n      type: 'reply'\n   },\n   259: {\n      name: 'rpl_adminemail',\n      type: 'reply'\n   },\n   261: {\n      name: 'rpl_tracelog',\n      type: 'reply'\n   },\n   265: {\n      name: 'rpl_localusers',\n      type: 'reply'\n   },\n   266: {\n      name: 'rpl_globalusers',\n      type: 'reply'\n   },\n   300: {\n      name: 'rpl_none',\n      type: 'reply'\n   },\n   301: {\n      name: 'rpl_away',\n      type: 'reply'\n   },\n   302: {\n      name: 'rpl_userhost',\n      type: 'reply'\n   },\n   303: {\n      name: 'rpl_ison',\n      type: 'reply'\n   },\n   305: {\n      name: 'rpl_unaway',\n      type: 'reply'\n   },\n   306: {\n      name: 'rpl_nowaway',\n      type: 'reply'\n   },\n   311: {\n      name: 'rpl_whoisuser',\n      type: 'reply'\n   },\n   312: {\n      name: 'rpl_whoisserver',\n      type: 'reply'\n   },\n   313: {\n      name: 'rpl_whoisoperator',\n      type: 'reply'\n   },\n   314: {\n      name: 'rpl_whowasuser',\n      type: 'reply'\n   },\n   315: {\n      name: 'rpl_endofwho',\n      type: 'reply'\n   },\n   317: {\n      name: 'rpl_whoisidle',\n      type: 'reply'\n   },\n   318: {\n      name: 'rpl_endofwhois',\n      type: 'reply'\n   },\n   319: {\n      name: 'rpl_whoischannels',\n      type: 'reply'\n   },\n   321: {\n      name: 'rpl_liststart',\n      type: 'reply'\n   },\n   322: {\n      name: 'rpl_list',\n      type: 'reply'\n   },\n   323: {\n      name: 'rpl_listend',\n      type: 'reply'\n   },\n   324: {\n      name: 'rpl_channelmodeis',\n      type: 'reply'\n   },\n   329: {\n      name: 'rpl_creationtime',\n      type: 'reply'\n   },\n   331: {\n      name: 'rpl_notopic',\n      type: 'reply'\n   },\n   332: {\n      name: 'rpl_topic',\n      type: 'reply'\n   },\n   333: {\n      name: 'rpl_topicwhotime',\n      type: 'reply'\n   },\n   341: {\n      name: 'rpl_inviting',\n      type: 'reply'\n   },\n   342: {\n      name: 'rpl_summoning',\n      type: 'reply'\n   },\n   351: {\n      name: 'rpl_version',\n      type: 'reply'\n   },\n   352: {\n      name: 'rpl_whoreply',\n      type: 'reply'\n   },\n   353: {\n      name: 'rpl_namreply',\n      type: 'reply'\n   },\n   364: {\n      name: 'rpl_links',\n      type: 'reply'\n   },\n   365: {\n      name: 'rpl_endoflinks',\n      type: 'reply'\n   },\n   366: {\n      name: 'rpl_endofnames',\n      type: 'reply'\n   },\n   367: {\n      name: 'rpl_banlist',\n      type: 'reply'\n   },\n   368: {\n      name: 'rpl_endofbanlist',\n      type: 'reply'\n   },\n   369: {\n      name: 'rpl_endofwhowas',\n      type: 'reply'\n   },\n   371: {\n      name: 'rpl_info',\n      type: 'reply'\n   },\n   372: {\n      name: 'rpl_motd',\n      type: 'reply'\n   },\n   374: {\n      name: 'rpl_endofinfo',\n      type: 'reply'\n   },\n   375: {\n      name: 'rpl_motdstart',\n      type: 'reply'\n   },\n   376: {\n      name: 'rpl_endofmotd',\n      type: 'reply'\n   },\n   381: {\n      name: 'rpl_youreoper',\n      type: 'reply'\n   },\n   382: {\n      name: 'rpl_rehashing',\n      type: 'reply'\n   },\n   391: {\n      name: 'rpl_time',\n      type: 'reply'\n   },\n   392: {\n      name: 'rpl_usersstart',\n      type: 'reply'\n   },\n   393: {\n      name: 'rpl_users',\n      type: 'reply'\n   },\n   394: {\n      name: 'rpl_endofusers',\n      type: 'reply'\n   },\n   395: {\n      name: 'rpl_nousers',\n      type: 'reply'\n   },\n   401: {\n      name: 'err_nosuchnick',\n      type: 'error'\n   },\n   402: {\n      name: 'err_nosuchserver',\n      type: 'error'\n   },\n   403: {\n      name: 'err_nosuchchannel',\n      type: 'error'\n   },\n   404: {\n      name: 'err_cannotsendtochan',\n      type: 'error'\n   },\n   405: {\n      name: 'err_toomanychannels',\n      type: 'error'\n   },\n   406: {\n      name: 'err_wasnosuchnick',\n      type: 'error'\n   },\n   407: {\n      name: 'err_toomanytargets',\n      type: 'error'\n   },\n   409: {\n      name: 'err_noorigin',\n      type: 'error'\n   },\n   411: {\n      name: 'err_norecipient',\n      type: 'error'\n   },\n   412: {\n      name: 'err_notexttosend',\n      type: 'error'\n   },\n   413: {\n      name: 'err_notoplevel',\n      type: 'error'\n   },\n   414: {\n      name: 'err_wildtoplevel',\n      type: 'error'\n   },\n   421: {\n      name: 'err_unknowncommand',\n      type: 'error'\n   },\n   422: {\n      name: 'err_nomotd',\n      type: 'error'\n   },\n   423: {\n      name: 'err_noadmininfo',\n      type: 'error'\n   },\n   424: {\n      name: 'err_fileerror',\n      type: 'error'\n   },\n   431: {\n      name: 'err_nonicknamegiven',\n      type: 'error'\n   },\n   432: {\n      name: 'err_erroneusnickname',\n      type: 'error'\n   },\n   433: {\n      name: 'err_nicknameinuse',\n      type: 'error'\n   },\n   436: {\n      name: 'err_nickcollision',\n      type: 'error'\n   },\n   441: {\n      name: 'err_usernotinchannel',\n      type: 'error'\n   },\n   442: {\n      name: 'err_notonchannel',\n      type: 'error'\n   },\n   443: {\n      name: 'err_useronchannel',\n      type: 'error'\n   },\n   444: {\n      name: 'err_nologin',\n      type: 'error'\n   },\n   445: {\n      name: 'err_summondisabled',\n      type: 'error'\n   },\n   446: {\n      name: 'err_usersdisabled',\n      type: 'error'\n   },\n   451: {\n      name: 'err_notregistered',\n      type: 'error'\n   },\n   461: {\n      name: 'err_needmoreparams',\n      type: 'error'\n   },\n   462: {\n      name: 'err_alreadyregistred',\n      type: 'error'\n   },\n   463: {\n      name: 'err_nopermforhost',\n      type: 'error'\n   },\n   464: {\n      name: 'err_passwdmismatch',\n      type: 'error'\n   },\n   465: {\n      name: 'err_yourebannedcreep',\n      type: 'error'\n   },\n   467: {\n      name: 'err_keyset',\n      type: 'error'\n   },\n   471: {\n      name: 'err_channelisfull',\n      type: 'error'\n   },\n   472: {\n      name: 'err_unknownmode',\n      type: 'error'\n   },\n   473: {\n      name: 'err_inviteonlychan',\n      type: 'error'\n   },\n   474: {\n      name: 'err_bannedfromchan',\n      type: 'error'\n   },\n   475: {\n      name: 'err_badchannelkey',\n      type: 'error'\n   },\n   481: {\n      name: 'err_noprivileges',\n      type: 'error'\n   },\n   482: {\n      name: 'err_chanoprivsneeded',\n      type: 'error'\n   },\n   483: {\n      name: 'err_cantkillserver',\n      type: 'error'\n   },\n   491: {\n      name: 'err_nooperhost',\n      type: 'error'\n   },\n   501: {\n      name: 'err_umodeunknownflag',\n      type: 'error'\n   },\n   502: {\n      name: 'err_usersdontmatch',\n      type: 'error'\n   }\n};\n","/home/travis/build/npmtest/node-npmtest-irc/irc/lib/cycling_ping_timer.js":"'use strict';\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * This class encapsulates the ping timeout functionality. When enough\n * silence (lack of server-sent activity) time passes, an object of this type\n * will emit a 'wantPing' event, indicating you should send a PING message\n * to the server in order to get some signs of life from it. If enough\n * time passes after that (i.e. server does not respond to PING), then\n * an object of this type will emit a 'pingTimeout' event.\n *\n * To start the gears turning, call start() on an instance of this class To\n * put it in the 'started' state.\n *\n * When server-side activity occurs, call notifyOfActivity() on the object.\n *\n * When a pingTimeout occurs, the object will go into the 'stopped' state.\n */\nvar ctr = 0;\n\nfunction CyclingPingTimer(client) {\n    var timerNumber = ctr++;\n    var started = false;\n    var self = this;\n\n    // Only one of these two should be non-null at any given time.\n    var loopingTimeout = null;\n    var pingWaitTimeout = null;\n\n    // conditionally log debug messages\n    function debug(msg) {\n        if (client.opt.debug) {\n            console.error('CyclingPingTimer ' + timerNumber + ': ' + msg);\n        }\n    }\n\n    // set up EventEmitter functionality\n    EventEmitter.call(self);\n\n    self.on('wantPing', function() {\n        debug('server silent for too long, let\\'s send a PING');\n        pingWaitTimeout = setTimeout(function() {\n            self.stop();\n            debug('ping timeout!');\n            self.emit('pingTimeout');\n        }, client.opt.millisecondsBeforePingTimeout);\n    });\n\n    self.notifyOfActivity = function() {\n        if (started) {\n            self.stop();\n            self.start();\n        }\n    };\n\n    self.stop = function() {\n        if (!started) {\n            return;\n        }\n        started = false;\n\n        clearTimeout(loopingTimeout);\n        clearTimeout(pingWaitTimeout);\n\n        loopingTimeout = null;\n        pingWaitTimeout = null;\n    };\n\n    self.start = function() {\n        if (started) {\n            debug('can\\'t start, not stopped!');\n            return;\n        }\n        started = true;\n\n        loopingTimeout = setTimeout(function() {\n            loopingTimeout = null;\n            self.emit('wantPing');\n        }, client.opt.millisecondsOfSilenceBeforePingSent);\n    };\n}\n\nutil.inherits(CyclingPingTimer, EventEmitter);\n\nmodule.exports = CyclingPingTimer;\n"}